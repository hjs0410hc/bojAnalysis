# BOJ 1697 숨바꼭질 S1

## 문제

동생은 움직이지 않는다. 수빈이는 1칸 걷거나 순간이동하여 2xX의 위치로 이동할 수 있다.

동생을 찾는 최소 시간을 구하시오.

## 시간복잡도

위치는 모두 10만 이하, 시간제한 2초.

## 유형 파악

BFS로 될 것 같은디...

## 풀이

BFS로 풀렸다.

실수: 위치를 20만까지 갈 수 있게 해놨는데 정작 배열은 10만까지로 해놔서 OoB 런타임 오류가 발생했다.

```cpp
while(!q.empty()){
        int cur = q.front();
        q.pop();
        if(cur == k)break;

        if(path[2*cur] == -1 && 2*cur >= 0 && 2*cur <= 200000){
            path[2*cur] = cur;
            q.push(2*cur);
        }
        if(path[cur+1] == -1 && cur+1 >= 0 && cur+1 <= 200000){
            path[cur+1]=cur;
            q.push(cur+1);
        }
        if(path[cur-1] == -1 && cur-1 >= 0 && cur-1 <= 200000){
            path[cur-1]=cur;
            q.push(cur-1);
        }
    }
```

이번엔 좀 다르게 풀었다. 경로를 파악할 수 있고, 방문 여부도 확인할 수 있도록 path를 작성했다. 나중에 이런 방법으로 하는게 좋을 것 같다.

BFS에서 break문이 없으면 시간 초과가 날 수 있다. 어차피 최소의 경우를 묻고 있으므로, 시간 초과가 날 수 있는 케이스는 주지 않을 것이다. 목표 지점에 가장 먼저 접근하는 것이 최소의 경우이다. (시간적으로)