# BOJ 2805 나무 자르기 S2

## 문제

나무 M미터가 필요.

목재절단기는 높이 H를 지정해야 한다. 이것 이상으로 키가 높은 나무가 잘린다.

적어도 M미터의, 최소의 나무를 가져가는 높이의 최댓값을 구하시오.

## 문제 유형 & 시간복잡도

시간제한 1초

나무의 수가 100만이다. 높이는 1000000000 이하이다. 이것을 높이에 대한 브루트포스로 하면 사망한다.

<여기에서 long long 을 파악할 수 있었어야 했다>

이것은 절단기 높이에 대한 BINARY SEARCH 가 정답이었던 것 같다. (기억상으로)

log2(1000000000) = 30
30*1000000 = 3천만
가능해보인다.

---

일단 나무 높이를 정렬한다.

중간 값에서 계산을 해본다. 만약 크면 낮추고, 작으면 높인다.

바이너리 서치의 전형적인 모습을 기억해둬야 한다.

# Binary Search

```cpp
int start{0}, end{마지막idx-1 or 마지막값}, middle;

while(start <= end){ // =이 붙는다
    middle = (start+end)/2
    
    if(action(mid) == target){
        ans = mid;
        break;
    }else if(action(mid) > target){ // 더 높다? 낮춰라.
        end=middle-1;
    }else if(action(mid) < target){ // 낮다? 높여라
        start=middle+1;
    }
}

// 못찾고 끝났다? 없음.
```

나무 자르기 문제에서는 정확한 값을 찾는게 아니므로 >=로 처리할 수 있었다. 대신 이때 break를 쓰면 안된다.

# 기본적인 PS 순서에 대해서

1. 시간제한, 메모리제한 본다
2. 상수 범위 본다 (알고리즘, long long 판단)
3. 문제 살짝 읽고 입력 같이 본다